name: CI/CD Pipeline

on:
  push:
    branches:
      - '*'
  pull_request:
    branches:
      - '*'

env:
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-backend:
    name: Build and Push Backend
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Verify secrets are set
        run: |
          if [ -z "${{ secrets.YC_IAM_TOKEN }}" ]; then
            echo "❌ ERROR: YC_IAM_TOKEN secret is not set or empty"
            exit 1
          fi
          if [ -z "${{ secrets.REGISTRY_ID }}" ]; then
            echo "❌ ERROR: REGISTRY_ID secret is not set or empty"
            exit 1
          fi
          echo "✅ Secrets are set"
          echo "Registry: cr.yandex"
          echo "Registry ID: ${{ secrets.REGISTRY_ID }}"

      - name: Login to Yandex Container Registry
        run: |
          echo "${{ secrets.YC_IAM_TOKEN }}" | \
            docker login --username iam --password-stdin cr.yandex

      - name: Build and push backend image
        env:
          REGISTRY_ID: ${{ secrets.REGISTRY_ID }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          YC_IAM_TOKEN: ${{ secrets.YC_IAM_TOKEN }}
        run: |
          cd CI
          chmod +x build_backend.sh
          ./build_backend.sh

  deploy-infra:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Create terraform.tfvars
        working-directory: infrastructure/serverless
        run: |
          cat > terraform.tfvars <<EOF
          yc_token = "${{ secrets.YC_IAM_TOKEN }}"
          yc_cloud_id = "${{ secrets.YC_CLOUD_ID }}"
          yc_folder_id = "${{ secrets.YC_FOLDER_ID }}"
          yc_zone = "${{ secrets.YC_ZONE }}"
          
          backend_image = "cr.yandex/${{ secrets.REGISTRY_ID }}/backend:${{ env.IMAGE_TAG }}"
          frontend_image = "cr.yandex/${{ secrets.REGISTRY_ID }}/frontend:latest"
          
          container_registry_id = "${{ secrets.REGISTRY_ID }}"
          
          static_bucket_name = "${{ secrets.STATIC_BUCKET_NAME }}"
          static_allowed_origins = [
            "https://${{ secrets.STATIC_BUCKET_NAME }}.website.yandexcloud.net",
          ]
          api_allowed_origins = [
            "https://${{ secrets.STATIC_BUCKET_NAME }}.website.yandexcloud.net",
            "http://localhost:3000",
            "http://localhost:5173",
          ]
          EOF

      - name: Terraform Init
        working-directory: infrastructure/serverless
        env:
          # Используем IAM токен для terraform
          YC_TOKEN: ${{ secrets.YC_IAM_TOKEN }}
        run: terraform init

      - name: Import existing service accounts (if needed)
        working-directory: infrastructure/serverless
        env:
          YC_TOKEN: ${{ secrets.YC_IAM_TOKEN }}
        run: |
          # Устанавливаем yc CLI и jq для импорта
          curl -s https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          export PATH="$PATH:$HOME/yandex-cloud/bin"
          # jq обычно уже установлен в GitHub Actions runner, но на всякий случай
          which jq || (sudo apt-get update && sudo apt-get install -y jq)
          
          # Получаем project_name из terraform.tfvars или используем дефолт
          PROJECT_NAME=$(grep -E '^project_name\s*=' terraform.tfvars 2>/dev/null | sed 's/.*= *"\(.*\)".*/\1/' || echo "")
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="devops-portfolio-serverless"
          fi
          
          # Получаем project_name из terraform.tfvars или используем дефолт
          PROJECT_NAME=$(grep -E '^project_name\s*=' terraform.tfvars 2>/dev/null | sed 's/.*= *"\(.*\)".*/\1/' || echo "")
          if [ -z "$PROJECT_NAME" ]; then
            PROJECT_NAME="devops-portfolio-serverless"
          fi
          
          echo "Using project_name: '$PROJECT_NAME'"
          
          # Получаем ID сервисных аккаунтов по имени
          SERVERLESS_SA_NAME="${PROJECT_NAME}-serverless-sa"
          STATIC_SITE_SA_NAME="${PROJECT_NAME}-static-site"
          
          echo "Looking for service accounts: '$SERVERLESS_SA_NAME' and '$STATIC_SITE_SA_NAME'"
          
          # Пробуем найти по имени
          SERVERLESS_SA_ID=$(yc iam service-account get --name "$SERVERLESS_SA_NAME" --format json 2>/dev/null | jq -r '.id // empty' || echo "")
          STATIC_SITE_SA_ID=$(yc iam service-account get --name "$STATIC_SITE_SA_NAME" --format json 2>/dev/null | jq -r '.id // empty' || echo "")
          
          # Если не нашли по имени, пробуем найти по паттерну в списке всех аккаунтов
          if [ -z "$SERVERLESS_SA_ID" ]; then
            echo "Not found by name, searching in all service accounts..."
            SERVERLESS_SA_ID=$(yc iam service-account list --format json 2>/dev/null | jq -r ".[] | select(.name | endswith(\"-serverless-sa\")) | .id" | head -1 || echo "")
          fi
          if [ -z "$STATIC_SITE_SA_ID" ]; then
            STATIC_SITE_SA_ID=$(yc iam service-account list --format json 2>/dev/null | jq -r ".[] | select(.name | endswith(\"-static-site\")) | .id" | head -1 || echo "")
          fi
          
          # Если всё ещё не нашли, используем известные ID из предыдущих ошибок (fallback)
          if [ -z "$SERVERLESS_SA_ID" ]; then
            echo "Trying known service account IDs from previous errors..."
            # Пробуем известные ID (из ошибок terraform)
            for known_id in "ajebh4qukejfcj3vurm1"; do
              if yc iam service-account get --id "$known_id" --format json >/dev/null 2>&1; then
                SERVERLESS_SA_ID="$known_id"
                echo "Found serverless SA by known ID: $known_id"
                break
              fi
            done
          fi
          
          if [ -z "$STATIC_SITE_SA_ID" ]; then
            for known_id in "aje6eo39svoevpsmv61o"; do
              if yc iam service-account get --id "$known_id" --format json >/dev/null 2>&1; then
                STATIC_SITE_SA_ID="$known_id"
                echo "Found static_site SA by known ID: $known_id"
                break
              fi
            done
          fi
          
          echo "Final IDs: serverless=$SERVERLESS_SA_ID, static_site=$STATIC_SITE_SA_ID"
          
          # Импортируем, если они существуют и не в state
          if [ -n "$SERVERLESS_SA_ID" ]; then
            echo "Importing existing service account: $SERVERLESS_SA_NAME ($SERVERLESS_SA_ID)"
            terraform import yandex_iam_service_account.serverless "$SERVERLESS_SA_ID" 2>/dev/null || echo "Service account serverless already in state or import failed"
          else
            echo "Service account $SERVERLESS_SA_NAME not found, will be created"
          fi
          
          if [ -n "$STATIC_SITE_SA_ID" ]; then
            echo "Importing existing service account: $STATIC_SITE_SA_NAME ($STATIC_SITE_SA_ID)"
            terraform import yandex_iam_service_account.static_site "$STATIC_SITE_SA_ID" 2>/dev/null || echo "Service account static_site already in state or import failed"
          else
            echo "Service account $STATIC_SITE_SA_NAME not found, will be created"
          fi

      - name: Terraform Apply
        working-directory: infrastructure/serverless
        env:
          YC_TOKEN: ${{ secrets.YC_IAM_TOKEN }}
          TF_INPUT: "false"
        run: terraform apply -auto-approve

      - name: Save Terraform Outputs
        working-directory: infrastructure/serverless
        run: terraform output -json > terraform-outputs.json

      - name: Upload Terraform artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: infrastructure/serverless/
          retention-days: 1
  #
  # build-frontend:
  #   name: Build and Deploy Frontend
  #   runs-on: ubuntu-latest
  #   needs: deploy-infra
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Download Terraform artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         name: terraform-state
  #         path: infrastructure/serverless/
  #
  #     - name: Install Yandex Cloud CLI
  #       run: |
  #         curl https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
  #         echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH
  #         yc --version
  #
  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: '20'
  #         cache: 'npm'
  #         cache-dependency-path: frontend/package-lock.json
  #
  #     - name: Extract Terraform outputs
  #       working-directory: infrastructure/serverless
  #       run: |
  #         export API_GATEWAY_ENDPOINT=$(jq -r '.api_gateway_endpoint.value' terraform-outputs.json)
  #         export STATIC_BUCKET_NAME=$(jq -r '.static_bucket_name.value' terraform-outputs.json)
  #         export AWS_ACCESS_KEY_ID=$(jq -r '.static_site_access_key.value' terraform-outputs.json)
  #         export AWS_SECRET_ACCESS_KEY=$(jq -r '.static_site_secret_key.value' terraform-outputs.json)
  #         echo "API_GATEWAY_ENDPOINT=${API_GATEWAY_ENDPOINT}" >> $GITHUB_ENV
  #         echo "STATIC_BUCKET_NAME=${STATIC_BUCKET_NAME}" >> $GITHUB_ENV
  #         echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}" >> $GITHUB_ENV
  #         echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}" >> $GITHUB_ENV
  #         echo "API_GATEWAY_ENDPOINT=${API_GATEWAY_ENDPOINT}"
  #         echo "STATIC_BUCKET_NAME=${STATIC_BUCKET_NAME}"
  #
  #     - name: Build and deploy frontend
  #       working-directory: CI
  #       env:
  #         API_GATEWAY_ENDPOINT: ${{ env.API_GATEWAY_ENDPOINT }}
  #         STATIC_BUCKET_NAME: ${{ env.STATIC_BUCKET_NAME }}
  #         AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
  #       run: |
  #         chmod +x build_frontend.sh
  #         ./build_frontend.sh

